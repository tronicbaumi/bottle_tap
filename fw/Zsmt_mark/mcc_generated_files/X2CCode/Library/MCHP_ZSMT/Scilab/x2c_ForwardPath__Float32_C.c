// This file was generated by createCFunction.sci on 10-08-2023 12:11

// Computational function for X2C block ForwardPath_HFI

#define SCILAB_SIM_FILE /* mark this file as Scilab simulation file */

/* include Scicos / Xcos headers */
#include <scicos.h>
#include <scicos_block4.h>
#include <scicos_malloc.h>
#include <scicos_free.h>
#include <Simulation_PortConversion.h>
//#define DEBUG // uncomment to enable debugging
#ifdef DEBUG
    #include <stdio.h>
#endif

/* include block implementation */
#include <ForwardPath_HFI_Float32.h>
#include <ForwardPath_HFI_Float32.c>

/* */
#define BLOCK_ERROR_INPUT_OUT_OF_DOMAIN (-1)
#define BLOCK_ERROR_SINGULARITY (-2)
#define BLOCK_ERROR_INTERNAL (-3)
#define BLOCK_ERROR_CANNOT_ALLOCATE_MEMORY (-16)

/* */
void x2c_ForwardPath__Float32_C(scicos_block* block, scicos_flag flag);
static void x2c_ForwardPath__Float32_C__OutputUpdate(scicos_block* block);
static void x2c_ForwardPath__Float32_C__StateUpdate(scicos_block* block);
static void x2c_ForwardPath__Float32_C__Initialization(scicos_block* block);
static void x2c_ForwardPath__Float32_C__Ending(scicos_block* block);


void x2c_ForwardPath__Float32_C(scicos_block* block, scicos_flag flag) {
    /*
     * This function will be called by Xcos
     */
    switch (flag) {
        case DerivativeState:  /* 0 */
        {
            break;
        }
        case OutputUpdate:     /* 1 */
        {
            x2c_ForwardPath__Float32_C__OutputUpdate(block);
            break;
        }
        case StateUpdate:      /* 2 */
        {
            x2c_ForwardPath__Float32_C__StateUpdate(block);
            break;
        }
        case OutputEventTiming: /* 3 */
        {
            break;
        }
        case Initialization:   /* 4 */
        {
            x2c_ForwardPath__Float32_C__Initialization(block);
            break;
        }
        case Ending:           /* 5 */
        {
            x2c_ForwardPath__Float32_C__Ending(block);
            break;
        }
        case ReInitialization: /* 6 */
        {
            break;
        }
        case ZeroCrossing:     /* 9 */
        {
           break;
        }
        default:     /* ContinousPropertiesUpdate (v5.5.x) Jacobian (v5.5.x) or Residute (v5.4.1) or something else */
        {
           break;
        }
    }
}


static void x2c_ForwardPath__Float32_C__set_parameter(scicos_block* block, FORWARDPATH_HFI_FLOAT32 *blockParam) {
    int *paramI;
    double *paramR;
    FORWARDPATH_HFI_FLOAT32 *pTForwardPath_HFI_Float32;
    
    /* *** */
    paramI = GetIparPtrs(block);  /* integer parameters  */
    paramR = GetRparPtrs(block);  /* real parameters     */
    pTForwardPath_HFI_Float32 = GetWorkPtrs(block);
    blockParam->HF_InjectionPolarity = (bool)paramI[0];
}


static void x2c_ForwardPath__Float32_C__Initialization(scicos_block* block) {
    FORWARDPATH_HFI_FLOAT32 *pTForwardPath_HFI_Float32;
    int16 arrayStart = 0;

    /* Declaration of inports */
    double *inport_Ud_p;
    float32 inport_Ud;
    double *inport_Uq_p;
    float32 inport_Uq;
    double *inport_UdHF_p;
    float32 inport_UdHF;
    double *inport_theta_p;
    float32 inport_theta;

    /* Declaration of outports */
    double *outport_Va;
    double *outport_Vb;
    double *outport_Vc;
    double *outport_Valpha;
    double *outport_Vbeta;

    /* *** */
    pTForwardPath_HFI_Float32 = scicos_malloc(sizeof(FORWARDPATH_HFI_FLOAT32));
    GetWorkPtrs(block) = pTForwardPath_HFI_Float32;
    x2c_ForwardPath__Float32_C__set_parameter(block, pTForwardPath_HFI_Float32);

    /* Assignment of inports */
    inport_Ud_p = GetInPortPtrs(block, 1);
    inport_Ud = convert_double_to_float32(*inport_Ud_p);
    pTForwardPath_HFI_Float32->Ud = &inport_Ud;
    inport_Uq_p = GetInPortPtrs(block, 2);
    inport_Uq = convert_double_to_float32(*inport_Uq_p);
    pTForwardPath_HFI_Float32->Uq = &inport_Uq;
    inport_UdHF_p = GetInPortPtrs(block, 3);
    inport_UdHF = convert_double_to_float32(*inport_UdHF_p);
    pTForwardPath_HFI_Float32->UdHF = &inport_UdHF;
    inport_theta_p = GetInPortPtrs(block, 4);
    inport_theta = convert_double_to_float32(*inport_theta_p);
    pTForwardPath_HFI_Float32->theta = &inport_theta;

    /* Assignment of parameter arrays */
    arrayStart = 0;

    /* Initialization */
    ForwardPath_HFI_Float32_Init(pTForwardPath_HFI_Float32);

    /* Assignment of outports */
    outport_Va = GetOutPortPtrs(block, 1);
    *outport_Va = convert_float32_to_double(pTForwardPath_HFI_Float32->Va);
    outport_Vb = GetOutPortPtrs(block, 2);
    *outport_Vb = convert_float32_to_double(pTForwardPath_HFI_Float32->Vb);
    outport_Vc = GetOutPortPtrs(block, 3);
    *outport_Vc = convert_float32_to_double(pTForwardPath_HFI_Float32->Vc);
    outport_Valpha = GetOutPortPtrs(block, 4);
    *outport_Valpha = convert_float32_to_double(pTForwardPath_HFI_Float32->Valpha);
    outport_Vbeta = GetOutPortPtrs(block, 5);
    *outport_Vbeta = convert_float32_to_double(pTForwardPath_HFI_Float32->Vbeta);

    /* Update of parameter arrays */
    arrayStart = 0;
}


static void x2c_ForwardPath__Float32_C__Ending(scicos_block* block) {
    FORWARDPATH_HFI_FLOAT32 *pTForwardPath_HFI_Float32;
    pTForwardPath_HFI_Float32 = GetWorkPtrs(block);
    scicos_free(pTForwardPath_HFI_Float32);
}


static void x2c_ForwardPath__Float32_C__StateUpdate_f(scicos_block* block) {
    /* No time dependency -> execute Update function and Output assignment in Output Update function */
}


static void x2c_ForwardPath__Float32_C__StateUpdate(scicos_block* block) {
    if (GetNevIn(block) > 0) {
        /*
        * GetNevIn(block) returns -1 in case this function was called due to an internal zero-crossing.
        * GetNevIn(block)  ... activation index
        */
        x2c_ForwardPath__Float32_C__StateUpdate_f(block);
    }
}


static void x2c_ForwardPath__Float32_C__OutputUpdate(scicos_block* block) {
    FORWARDPATH_HFI_FLOAT32 *pTForwardPath_HFI_Float32;
    int16 arrayStart = 0;

    /* Declaration of inports */
    double *inport_Ud_p;
    float32 inport_Ud;
    double *inport_Uq_p;
    float32 inport_Uq;
    double *inport_UdHF_p;
    float32 inport_UdHF;
    double *inport_theta_p;
    float32 inport_theta;

    /* Declaration of outports */
    double *outport_Va;
    double *outport_Vb;
    double *outport_Vc;
    double *outport_Valpha;
    double *outport_Vbeta;

    /* *** */
    pTForwardPath_HFI_Float32 = GetWorkPtrs(block);

    /* Assignment of inports */
    inport_Ud_p = GetInPortPtrs(block, 1);
    inport_Ud = convert_double_to_float32(*inport_Ud_p);
    pTForwardPath_HFI_Float32->Ud = &inport_Ud;
    inport_Uq_p = GetInPortPtrs(block, 2);
    inport_Uq = convert_double_to_float32(*inport_Uq_p);
    pTForwardPath_HFI_Float32->Uq = &inport_Uq;
    inport_UdHF_p = GetInPortPtrs(block, 3);
    inport_UdHF = convert_double_to_float32(*inport_UdHF_p);
    pTForwardPath_HFI_Float32->UdHF = &inport_UdHF;
    inport_theta_p = GetInPortPtrs(block, 4);
    inport_theta = convert_double_to_float32(*inport_theta_p);
    pTForwardPath_HFI_Float32->theta = &inport_theta;

    /* Assignment of parameter arrays */

    /* Update */
    ForwardPath_HFI_Float32_Update(pTForwardPath_HFI_Float32);

    /* Assignment of outports */
    outport_Va = GetOutPortPtrs(block, 1);
    *outport_Va = convert_float32_to_double(pTForwardPath_HFI_Float32->Va);
    outport_Vb = GetOutPortPtrs(block, 2);
    *outport_Vb = convert_float32_to_double(pTForwardPath_HFI_Float32->Vb);
    outport_Vc = GetOutPortPtrs(block, 3);
    *outport_Vc = convert_float32_to_double(pTForwardPath_HFI_Float32->Vc);
    outport_Valpha = GetOutPortPtrs(block, 4);
    *outport_Valpha = convert_float32_to_double(pTForwardPath_HFI_Float32->Valpha);
    outport_Vbeta = GetOutPortPtrs(block, 5);
    *outport_Vbeta = convert_float32_to_double(pTForwardPath_HFI_Float32->Vbeta);

    /* Update of parameter arrays */
    arrayStart = 0;
}


